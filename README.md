## Отчёт по лабораторной работе № 2

### № группы: ПМ-2501

### Выполнил: Замиралов Григорий

Вариант: 8
---
Содержание:
- [Задание 1](#задание-1)
- [Задание 2](#задание-2)
- [Задание 3](#задание-3)
- [Задание 4](#задание-4)
---

# Задание 1
### 1.Постановка задачи
- Условие задачи
    >Ваша задача – посмотреть, какие значения принимает последовательность при разных a0 и n, вывести закономерность, по которой строится последовательность и запрограммировать ее самостоятельно.
  Ограничение сверху на n – искусственное, чтобы не упал весь сайт (а вы можете выбрать любое разумное ограничение самостоятельно). Если на ваш запрос сервер пятисотит (HTTP 500), значит ваша последовательность быстро растет, и питон сломался обрабатывать ее элементы, попробуйте вывести еще меньше элементов.

- Необходимо выявить закономерность от введённых `a0` и `n` и реализовать алгоритм для построения последовательности для любых входных значений

- Чтобы выявить закономерность будем вводить разные входные значения `a0` и `n` и анализировать полученные последовательности
- При вводе разных значений `a0` видно что каждое последующее число состовляется из суммы произведений значений разрядов предыдущего числа умноженного на 5
### 2. Входные и выходные данные

#### Данные на вход

Согласно условию задачи на вход подаются два целых числа, `a0`, 0 < `n` < 100


| Число |  Тип | Нижняя граница    | Верхняя граница  |
|-------|-----|-------------------|------------------|
| a0    |   ℤ | -2<sup>31</sup>-1 | 2<sup>31</sup>-1 |
| n     |    ℤ | 1                 | 100              |


#### Данные на выход

Программа будет возвращать целые числа.

| Число | Тип | Нижняя граница | Верхняя граница  |
|-------|----|-------|------------------|
| a     |  ℤ  | 0     | 2<sup>31</sup>-1 |

### 3. Выбор структуры данных

Программа на вход получает 2 натуральных числа, поэтому для их хранения достаточно выделить 2 переменных (a0,n)
типа int. Функция, выполняющая алгоритм также будет обрабатывать целое число 'c'

| Число | Название переменной |Тип переменной|
|-------|---------------------|--------------|
| a0    | a0                  |     int      |
| n     | n                   |     int      |
| c     | c                   |     int      |

Результат есть числа целые 

| Число | Название переменной | Тип переменной |
|-------|---------------------|----------------|
| a0    | a0                  | int            |

### 4. Алгоритм

#### Алгоритм выполнения программы

1. Ввод данных:    
   Программа считывает 2 натуральных числа a0 , n переменные которых названы соотвественно a0, n.

2. Выполнение цикла:    
   Программа на каждом шаге выводит на экран результат выполнения подпрограммы и задаёт следующее входное число в подпрограмму
3. Подпрограмма:   
Подпрограмма переводит число в абсолютную форму и прибавляет к результирующему числу `c` произведение каждого разряда числа умноженного на 5
### 5. Код программы
```java
import java.io.PrintStream;
import java.util.Scanner;
public class Number1 {
    public static Scanner in = new Scanner(System.in);
    public static PrintStream out = System.out;
    public static void  main(String [] args) {
        out.print("Введите a0: ");
        int a0 = in.nextInt();
        out.print("Введите n: ");
        int n = in.nextInt();
        for (int j = 0;j<n;++j) { // цикл для вывода всех значений
            out.print(sumdivmultipfive(a0) + " ");
            a0 = sumdivmultipfive(a0);
        }
    }
        static int sumdivmultipfive(int i) { //функция возвращает сумму цифр числа умноженных на 5
            i = Math.abs(i);  
            int c = 0;
            while (i>0) {
                c+=(i%10)*5;
                i/=10;
            }
            return c;
        }
    }
````
### 6.Тесты
#### Тест 1: a0 = 0,n = 10
##### Вывод: `0 0 0 0 0 0 0 0 0 0`
#### Тест 2: a0 = 1,n = 10
##### Вывод: `5 25 35 40 20 10 5 25 35 40`
#### Тест 3: a0 = -1,n = 10
##### Вывод: `5 25 35 40 20 10 5 25 35 40`
#### Тест 4: a0 = 11,n = 10
##### Вывод: `10 5 25 35 40 20 10 5 25 35`
#### Тест 5: a0 = -11,n = 10
##### Вывод: `10 5 25 35 40 20 10 5 25 35`
#### Тест 6: a0 = 1035,n = 33
##### Вывод: `45 45 45 45 45 45 45 45 45 45 45 45 45 45 45 45 45 45 45 45 45 45 45 45 45 45 45 45 45 45 45 45 45`

# Задание 2
### 1.Постановка задачи
- Условие задачи
>С клавиатуры вводится заглавная буква латинского алфавита и натуральное число N (N < 100). Вывести подряд N букв латинского алфавита, начиная с введенной. Если при этом буквы доходят до конца алфавита, счет продолжается с ‘A’. Буквы на нечетных позициях должны выводиться заглавными, а на четных – строчными.

- Данная задача предполагает анализ введённых значений и, отталкиваясь от введённой буквы, вывод следующих за ней по алфавиту букв, при этом, меняя их регистр в зависимости от чётности позиции в выходной строке. 

- Чтобы получить нужную строку надо также анализировать букву на сходство с последней в алфавите, если это произошло, то необходимо сдвинуть значение следующего символа на 26 (количество букв в латинском алфавите)

### 2. Входные и выходные данные

#### Данные на вход

Согласно условию задачи на вход подаётся строка, состоящая из символа и натурального числа длиной не более 100

| Переменная | Тип    | Нижняя граница | Верхняя граница |
|------------|--------|----------------|-----------------|
| bc         | String | -              | -               |


#### Данные на выход

На выходе мы получаем строку образованную из символов типа `char`

| Число | Тип  | Нижняя граница | Верхняя граница |
|-------|------|----------------|-----------------|
| bukva | char | -              | -               |

### 3. Выбор структуры данных

Программа на вход получает строку из 1-2 натуральных чисел и букву, поэтому для их хранения достаточно выделить 1 переменную
типа int и одну переменную типа char

| Число | Название переменной | Тип переменной |
|-------|---------------------|----------------|
| bukva | bukva               | char           |
| count | count               | int            |

### 4. Алгоритм

#### Алгоритм выполнения программы

1. Ввод данных:    
   Программа считывает 1 символ, потом формирует значение `count` в зависимости от количества разрядов в строке, используя условные операторы и перевод из `char` в `int`. 

2. Вывод данных:
    Циклически проверяем позицию буквы на чётность и на сходство с последним символом в алфавите. Выводим символ отличающийся на такое количество от изначального, сколько шагов цикла уже пройдена, попутно меняя регистр.

### 5.Код программы
```java
import java.io.PrintStream;
import java.util.Scanner;
import java.io.IOException;
public class Number2 {
    public static Scanner in = new Scanner(System.in);
    public static PrintStream out = System.out;
    public static void  main(String [] args) throws IOException {
        out.println("Введите заглавную букву латинского алфавита и число от 1 до 100:  ");
        String bc = in.nextLine();
        char bukva = bc.charAt(0);
        int count = 0;
        if (bc.length() == 2) // конвертируем число в int
            count = bc.charAt(1) -'0';
        else
            count = (bc.charAt(1) -'0') * 10 + (bc.charAt(2) -'0');
        out.print("Получим строку: ");
        for (int i = 0; i<count;++i) {
            if (i%2==0) // проверяем позицию буквы на чётность
                if ((char)(bukva+i) == 'Z') {
                out.print((char)(bukva+i)); // начинаем с начала алфавита, если дошли до конца
                bukva = (char)(bukva-26);  // 26 - кол-во букв в латинском алфавите
                }
                else
                    out.print((char)(bukva+i));
            else
                if ((char)(bukva+i+32) == 'z') { // строчные буквы отличаются своим кодом от прописных на 32 символа
                out.print((char)(bukva+i+32));
                bukva = (char)(bukva-26);
            }
                else
            out.print((char)(bukva+i+32));
        }
    }
}
```
### 6.Тесты
#### Тест 1: bc = S33. Вывод: `StUvWxYzAbCdEfGhIjKlMnOpQrStUvWxY`
#### Тест 2: bc = W11. Вывод: `WxYzAbCdEfG`
#### Тест 3: bc = A1. Вывод: `A`


# Задание 3
### 1.Постановка задачи
- Условие задачи
>Система нагревается и охлаждается по тикам. На каждом тике значение
> температуры T сначала увеличивается на L, затем уменьшается 
> на величину ⌊T * alpha / 100⌋ (⌊n⌋ – целая часть от n). 
> Безопасной зоной считается состояние, когда температура 
> не превышает порога H. Требуется определить, через сколько
> тиков температура впервые вернется в безопасную зону и какое
> значение будет иметь T в этот момент. Если опустить температуру
> до уровня H и ниже невозможно, выведите NO.

- Данная задача предполагает анализ значения температуры после каждого тика

- Если температура станет не больше необходимого порога, то нужно вывести значения температуры и количество тиков, если температура не стремится к заданному значению, то выводим сообщение о невозможности выполнения условия.
### 2. Входные и выходные данные

#### Данные на вход

Согласно условию задачи на вход подаются четыре целых числа (H,alpha,L,T0)

| Число |  Тип | Нижняя граница  |Верхняя граница |
|-------|----|-----------------|----------------|
| H     |   ℤ | -2<sup>31</sup> |2<sup>31</sup>-1|
| alpha |   ℤ | -2<sup>31</sup> |2<sup>31</sup>-1|
| L     |   ℤ | -2<sup>31</sup> |2<sup>31</sup>-1|
| T0    |   ℤ | -2<sup>31</sup>               |2<sup>31</sup>-1|


#### Данные на выход

Программа выводит два целых числа

| Число |Тип|Нижняя граница|Верхняя граница|
|-------|---|--------------|--------------|
| tick  | ℤ |     0        |    2<sup>31</sup>-1          |
| T     |   ℤ | -2<sup>31</sup> |2<sup>31</sup>-1|

### 3. Выбор структуры данных

Для входных данных выделим переменные типа int, также нам понадобиться три переменных для хранения счётчиков и  значения результирующего числа 

| Число | Название переменной |Тип переменной|
|-------|---------------------|--------------|
| H     | H                   |     int      |
| alpha | alpha               |     int      |
| L     | L                   |     int      |
| T0    | T0                  |     int      |
| T     | T                   |     int      |
| tick  | tick                |     int      |
| k     | k                   |     int      |

Результат есть два целых  числа

| Число |Название переменной|Тип переменной|
|-------|-------------------|--------------|
| T     | T                   |     int      |
| tick  | tick                |     int      |

### 4. Алгоритм

1. Ввод данных:    
   Программа считывает 4 целых числа H,alpha,L,T0 переменные которых названы соотвественно H,alpha,L,T0.

2. Цикл:    
Программа на каждом шагу цикла проверяет количество циклов на ограничение в 10000 тиков, заданное мной, так как, если температура не вошла в необходимую зону при выполнении такого количества шагов, то она уже вряд-ли достигнет его. На каждом шагу цикла проверяем, стала ли текущая температура не больше необходимого порога, если да, то выводим значения, прибавляем 1 к счётчику, который является индикатором выполнения условия и завершаем цикл, если нет, то выполняем указанные операции  и прибавляем 1 к счётчику тиков.
3. Если индикатор выполнения цикла остался нулевым, то выводим `NO`.

### 5.Код программы
```java
import java.io.PrintStream;
import java.io.PrintStream;
import java.util.Scanner;
import java.io.IOException;
public class Number3 {
    public static Scanner in = new Scanner(System.in);
    public static PrintStream out = System.out;
    public static void main(String[] args) throws IOException {
        int H = in.nextInt();
        int alpha = in.nextInt();
        int L = in.nextInt();
        int T0 = in.nextInt();;
        int T = T0;
        int tick = 0;
        int k = 0; // переменная для проверки выполнения условия
        while (tick<1000000000) {   // ставим ограничение по тикам, чтобы примерно понимать, когда температура постоянно будет больше необходимого значения
            if (T < H) {
                out.println("Понадобившееся количество тиков:" + tick + ", Температура:" + T);
                k+=1;
                break;   //если температура попала в необходимый промежуток возвращаем значения и завершаем цикл
            }
            T+=L;
            T-=(T*alpha)/100;
            tick++;
        }
        if (k==0)
            out.println("NO"); // выводим, если условие не выполнилось за определённое количество тиков
    }
}
```
### 6.Тесты
#### Тест 1: `100 10 15 155` Вывод: `NO`
#### Тест 2: `100 30 15 155` Вывод: `Понадобившееся количество тиков:2, Температура:94`
#### Тест 3: `100 30 15 1500` Вывод: `Понадобившееся количество тиков:9, Температура:96`
#### Тест 4: `500 10 5 13000` Вывод: `Понадобившееся количество тиков:32, Температура:494`
# Задание 4
### 1.Постановка задачи
- Условие задачи
>Дан массив из n чисел. Найти элемент,
> значение которого ближе всего к среднему
> арифметическому остальных элементов. Вывести 
> его значение и расположение в массиве.

- Данная задача предполагает подсчёт разницы между каждым числом в массиве и средним арифметическим массива без этого числа, при этом сохраняя значение его порядкового номера.

- Между получившихся значений нужно вывести минимальное и его порядковый номер в массиве.
-
### 2. Входные и выходные данные

#### Данные на вход

Согласно условию задачи на вход подаётся целое число `n` являющееся значением длины массива.

| Число |  Тип   |Нижняя граница|Верхняя граница |
|-------|--------|--------------|----------------|
| n     |   ℕ    |      1       |2<sup>31</sup>-1|

#### Данные на выход
Для выходных данных используется ццелочисленная переменная index, как для необходимого элемента, так и для позиции его позиции в массиве

| Число |Тип|Нижняя граница|Верхняя граница|
|-------|---|--------------|--------------|
| index | ℤ |     0        |       2<sup>31</sup>-1       |

### 3. Выбор структуры данных
Для хранения длины массива будем использовать переменную `n` типа данных `int`, сам массив также будет целочисленным. Для хранения промежуточных значений буду использовать две целочисленных переменных `index` и `znachenie` типа `int`.  

| Число     | Название переменной |Тип переменной|
|-----------|---------------------|--------------|
| n         | n                   |     int      |
| []arr     | []arr               |     int      |
| index     | index               |     int      |
| znachenie | znachenie           |     int      |

Результат есть число

| Число | Название переменной | Тип переменной |
|-------|---------------------|----------------|
| index | index               | int            |

### 4. Алгоритм

#### Алгоритм выполнения программы

1. Ввод данных:    
   Программа считывает натуральное число `n`, создаёт массив этой длины и с помощью цикла заполняет его значениями, введёнными с клавиатуры.
2. Цикл нахождения нужного числа:
    Задаём начальное значение для переменной хранящей значение числа первый элемент из цикла, далее с каждым шагом сравниваем его с значением подпрограммы и перезадаем его значение и индекс, если результат функции окажется меньше, чем нынешнее значение.  
3. Подпрограмма:
    Подпрограмма получает на вход массив и индекс элемента в нём, суммирует все элементы кроме нужного элемента с помощью цикла и делит на количество эл-тов в массиве - 1. Функция возвращает модуль разности между найденным средним арифметическим и заданным числом.
4. Вывод:
    Выводим искомый элемент массива и его позицию.



### 5.Код программы
```java
import java.io.PrintStream;
import java.io.PrintStream;
import java.util.Scanner;
import java.io.IOException;
public class Number4 {
    public static Scanner in = new Scanner(System.in);
    public static PrintStream out = System.out;
    static int func(int []a, int c) {
        int sum = -c; //начинаем с -с чтобы получить сумму всех чисел кроме с
        int l = a.length-1; // берём количество эл-тов не считая выбранный
        for ( int j = 0;j<a.length;++j)
            sum+=a[j];
        int sra = sum/l; //считаем среднее арифметическое
        return Math.abs(c-sra);  //возвращаем искомое значение
    }
    public static void  main(String [] args) throws IOException {
        int n  = in.nextInt();
        int []arr = new int[n];
        for (int i = 0; i<arr.length;++i)
            arr[i] = in.nextInt();
        int index = 0;     //переменная для хранения индекса искомого числа
        int znachenie = func(arr,arr[0]);  // искомое значение, начинаем перебирать с первого эл-та
        for (int e = 1; e<arr.length;++e)
            if (func(arr,arr[e]) < znachenie) {  // если искомое значение текущей переменной, меньше минимально найденного
                znachenie = func(arr,arr[e]);    // обновляем минимум и индекс
                index = e;
            }
        out.println("Значение искомого элемента:" + arr[index]);
        out.println("Этот элемент находится на " + (index+1) + " позиции");
    }
}
```
### 6.Тесты
#### Тест 1: `5 12 13 14 15 16` Вывод: `Значение искомого элемента: 14    Этот элемент находится на 3 позиции`
#### Тест 2: `4 -100 100 1000 14313` Вывод: `Значение искомого элемента: 1000    Этот элемент находится на 3 позиции`
#### Тест 3: `5 -12 12 -232 54 -123` Вывод: `Значение искомого элемента: -12    Этот элемент находится на 1 позиции`
#### Тест 4: `10 1 2 3 4 5 6 7 8 9 0` Вывод: `Значение искомого элемента: 4    Этот элемент находится на 4 позиции`

